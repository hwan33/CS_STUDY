# 📌들어가기 앞서

## 프로세스 상태 (Process State)
- New(start, 생성중): 프로세스가 처음 메모리에 올라오는 단계
- Ready(준비): CPU를 받아서 바로 실행하길 기다리는 단계
- Running(실행): CPU로 명령어를 수행중인 상태
- Blocked(wait, sleep, 대기): 
  - CPU를 점유하더라도 명령어를 실행시킬 수 없는 상태 
  - 프로세스 자신이 요청한 event가 아직 완료되지 않아서 기다리는 상태 <br>
    **💡 ex) 디스크에서 file read, 사용자 입력을 기다리는 경우와 같이 시스템 콜이 아직 완료되지 않았을 때**
- Terminated(end, 종료중): 프로세스 수행을 끝마치고 OS에 종료를 요청하는 상태

<br>

## 프로세스 상태 변화
![프로세스 상태 전이](https://user-images.githubusercontent.com/48471292/137421769-46196ea5-80af-46f5-ae69-d5d8a1e41aa7.jpg)
(출처: https://rebas.kr/852)

- **Admitted(승인):** 프로세스의 메모리 적재가 완료되어 실행 가능한 상태가 됨
- **Scheduler Dispatch:** Ready 상태에 있는 프로세스 중 하나를 선택해서 실행 
- **Interrupt:** Timer interrupt, 예외 상황으로 인한 interrupt 등으로 현재 프로세스를 준비 상태로 바꾸고, 다른 작업을 먼저 처리하는 것
- **I/0 or Event Wait:** I/O 같은 프로세스의 OS 자원 요청(시스템 콜) 이벤트가 끝날 때까지 프로세스를 대기 상태로 만드는 것
- **I/O or Event Completion:** 프로세스가 요청한 이벤트가 완료되면 CPU에게 interrupt 걸어서 프로세스를 준비 상태 변경하는 것

<br>

# 📌CPU 스케줄링

## 스케줄링이란?
프로세스들의 상태 변화를 조정함으로써, **어떤** 프로세스가, **언제**, **얼마나 오랫동안** CPU를 할당받을지를 결정하는 것을 말한다.

<br>

## 스케줄링은 왜 필요할까?
모든 프로세스들은 공평하게 실행될 필요가 있으며, 때에 따라 긴급한 프로세스는 먼저 처리되어야 한다.
또한, CPU의 노는 시간은 최대한 줄여서 최대한 많은 작업을 처리할 수 있다면 더 좋을 것이다.
**이처럼 상황에 맞게 효과적이면서, 전체 프로세스를 효율적으로 처리하기 위해서 스케줄링 정책이 필요하다.**

<br>

## 스케줄링의 목적
CPU 스케줄링을 통해 달성하고자 하는 목적은 다음과 같다.

1. **공평성:** 모든 프로세스가 자원을 공평하게 배정받아야 하며, 특정 프로세스가 배제되어서는 안 된다.
2. **효율성:** 시스템 자원이 유휴 시간 없이 사용되도록 스케줄링을 하고, 유휴 자원을 사용하려는 프로세스에는 우선권을 주어야 한다.
3. **안정성:** 우선순위를 사용하여 중요한 프로세스가 먼저 처리되도록 해야 한다.
4. **반응 시간 보장:** 응답이 없는 경우 사용자는 시스템이 멈춘 것으로 가정하기 때문에 시스템은 적절한 시간 안에 프로세스의 요구에 반응해야 한다.
5. **무한 연기 방지:** 특정 프로세스의 작업이 무한히 연기되어서는 안 된다.

<br>

## 스케줄링 단계
1. 고수준 스케줄링(Long-term Scheduling)
   - 작업 스케줄링(Job Scheduling)이라고도 부른다.
   - OS에 등록된 프로세스 수와 부하를 고려해서 프로그램의 적재를 허용하거나 거부한다. 
2. 중간 수준 스케줄링(Midium-term Scheduling)
   - 프로세스의 중지(suspend)와 활성화(active)를 통해 OS의 전체 활성화된 프로세스의 수를 조절한다.
   - 저수준 스케줄링이 완만하게 이루어지도록 완충하는 역할을 한다
3. **저수준 스케줄링**
   - 가장 작은 단위의 스케줄링으로 프로세스의 Running, Ready, Wait 상태를 결정한다.
   - 중간 스케줄링은 프로세스를 보류 상태로, 저수준 스케줄링은 대기 상태로 보낸다.
   - **스케줄링에 대해 공부하는 대부분의 내용이 이에 해당한다.**

<br>

## 선점형(preemptive) vs 비선점형(non-preemptive) 스케줄링
- **선점형 스케줄링:** 프로세스가 CPU를 사용하는 중에 OS가 강제로 CPU를 회수할 수 있는 방식
- **비선점형 스케줄링:** 프로세스가 한번 CPU를 할당받고 나면, 스스로 시스템 콜을 하거나 실행이 완료되기 전까지 CPU를 반환하지 않는 방식

<br>

## 스케줄링 전략
### 1. FCFS(First-Come, First-Served, 선입 선처리)
   - Ready 큐에 도착한 순서대로 실행시키는, **비선점형**의 **선입선출** 방식
   - CPU Burst time이 훨씬 긴 프로세스가 먼저 도착했을 경우, 짧은 프로세스들은 모두 실행 시간에 비해 오래 대기해야 하는 단점이 있다.
        > 💡 **CPU Burst:** 시스템 콜 or 종료 전까지 CPU를 할당 받아서 실행하는 단계
        
        > 💡 **Convoy Effect(호위 효과):** 실행시간이 긴 프로세스로 인해, 뒤에 있는 프로세스들이 모두 그만큼 대기해야 하는 현상, 옛날 전쟁에서 무력이 센 장수 뒤에 있는 장수들이 오래 살아남는 현상에서 유래했다.

<br>

### 2. SJF(Shortest Job First, 최단 작업 우선)
![SRTF](https://user-images.githubusercontent.com/48471292/137431950-09356573-7a8d-4ca7-ad54-2db1e9276698.png)
(출처: https://bnzn2426.tistory.com/65)

  - 스케줄링 시, Ready Queue에서 CPU Burst time이 짧은 프로세스 순서대로 CPU를 할당하는 **비선점형** 방식
  - FCFS의 개선된 방식이지만, 긴 프로세스가 먼저 도착할 경우 여전히 호위 효과가 발생할 수 있으며 기아 현상(Starvation)이 일어날 수 있다.
    > 💡 **Starvation(기아 현상):** CPU 할당이 계속해서 지연되는 현상

    > 💡 **Aging 기법**: 기아 현상을 해결하는 기법으로,  

<br>

### 3. SRTF(Shortesst Remaining Time First, 최단 잔여 시간 우선)
 - SJF의 선점형 방식
 - 프로세스가 새로 들어오면, 현재 실행중인 프로세스의 잔여 시간과 비교해서 실행 시간이 더 짧은 프로세스가 CPU를 점유한다.
 - 어떤 알고리즘보다 전체 프로세스의 평균 대기 시간이 가장 짧다
 - **단점)** 
    1. 기아 현상이 더 심각하게 발생할 수 있다.
    2. CPU Burst time을 **정확하게** 예측할 수 없다.

<br>

### 4. Priority Scheduling(우선순위 스케줄링)
- 우선순위를 적용하여, 우선순위가 높은 프로세스에게 CPU를 우선적으로 할당하는 방식
- SJF, SRTF도 이에 해당한다.
> 💡 **Aging 기법:** 기다리는 시간에 비례하여 우선순위를 높이는 방식으로, 기아 현상을 해결할 수 있다. 

<br>

### 5. RR(Round Robin, 라운드 로빈)
- 요즘 사용되는 스케줄링 정책들의 기반이 되는 전략으로, **선점형**방식이다.
- CPU를 할당할 때마다 동일한 점유 시간(Timer Slice, Time Quantum)을 설정한다.
- 할당 시간이 끝나면, interrupt를 통해 CPU를 반납하고 ready queue로 들어간다.
- 타임 슬라이스가 끝나면, 
- Time slice가 작다 -> FCFS에 가까워 진다
- Time slice가 크다 -> 문맥교환으로 인한 오버헤드가 증가할 수 있다.
- **단점)**
  - 최적의 타임 슬라이스를 찾는 것이 어렵다
  - 모두 같은 타임 슬라이스를 적용하므로, 프로세스별 특성을 고려하지 않는다.

<br>

### 6. Multilevel Queue(다단계 큐)
![MQ](https://user-images.githubusercontent.com/48471292/137434538-9ac96769-f377-4661-b655-39f284c4fb7a.png)
(출처: https://bnzn2426.tistory.com/65)

- RR의 단점을 계선한 것으로, **Ready Queue를 여러 개 사용**하는 방식이다. 
- 프로세스 특성 별로 큐를 구성할 수도 있으며, 각 큐에 우선순위를 설정하고 프로세스의 우선순위에 따라 큐에 삽입한다.
- 설정된 우선순위는 바뀌지 않는다. 
- 각 queue는 특성에 맞는 독립적인 스케줄링 알고리즘을 사용할 수 있다.
  - ex) 
    1. interactive Queue -> RR 사용<br>
    2. batch Queue(상호작용이 거의 없는 프로세스) -> FCFS 사용
- 큐에 대한 스케줄링도 필요하다.
  - ex) 각 큐의 CPU 할당(Time Slice) 비율을 다르게 설정한다
- **단점:** 큐의 우선순위에 따른 기아 현상 가능성이 있다.

<br>

### 7. Multilevel Feedback Queue(다단계 피드백 큐)
![MLFQ](https://user-images.githubusercontent.com/48471292/137434773-e0c7bf32-ef65-4328-aea3-773961b349a7.png)
(출처: https://bnzn2426.tistory.com/65)

- 다단계 큐의 공평성 문제를 해결하기 위해 **우선순위 조정이 가능**한 방식이다. 즉, 프로세스의 queue간 이동이 가능하다.
- 스케줄링 정책에 따라 **처음에 어떤 큐**로 들어가고, 언제 **승격/강등**될지 결정된다.

    - ex)
      - 공평성을 위해 더 낮은 우선순위 큐의 CPU 할당 시간을 늘린다.
      -  1번 큐에서 타임 슬라이스를 모두 소진 -> 2번 큐로 강등
      - 2번 큐에서 타임 슬라이스 이전에 문맥 교환 발생 -> 1번 큐로 재승격
      - 1,2번에서 모두 슬라이스를 소진했음에도 실행 완료하지 못함 -> 3번 큐 강등, FCFS로 동작
  
  



<br>

# 📌참고
- 스케줄링 개요 및 전반적인 내용) 
  - http://www.kocw.net/home/cview.do?cid=4b9cd4c7178db077
  - https://bnzn2426.tistory.com/65
  - https://herong.tistory.com/entry/CPU-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81#:~:text=CPU%20%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81%EC%9D%98%20%EB%AA%A9%EC%A0%81,%EA%B2%83%20%EC%9D%B4%EB%9D%BC%20%ED%95%A0%20%EC%88%98%20%EC%9E%88%EB%8B%A4.
- 스케줄링 단계)
    - https://bnzn2426.tistory.com/65
    - https://herong.tistory.com/entry/CPU-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81#:~:text=CPU%20%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81%EC%9D%98%20%EB%AA%A9%EC%A0%81,%EA%B2%83%20%EC%9D%B4%EB%9D%BC%20%ED%95%A0%20%EC%88%98%20%EC%9E%88%EB%8B%A4.
- 스케줄링 상태 변화
    - https://core.ewha.ac.kr/publicview/C0101020170320150008154282
    - https://rebas.kr/852
    - https://prinha.tistory.com/entry/System-Programming-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%9D%98-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81%EA%B3%BC-%EC%83%81%ED%83%9C-%EB%B3%80%ED%99%94
- 스케줄링 알고리즘)
    - https://boycoding.tistory.com/258
    - https://bnzn2426.tistory.com/65


<br>

# 📌마치며 
위는 기본적인 스케줄링에 대한 개념입니다. 그 외에 멀티 프로세서 스케줄링과 실제 요새 사용되는 스케줄링 방식 등의 내용은 추후에 자세히 할 때 살펴보면 좋을 것 같습니다. 